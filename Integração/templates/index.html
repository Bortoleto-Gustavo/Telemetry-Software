<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <title>Live CSV Graph</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        #channelSelect { margin-bottom: 10px; }
        .checkbox-group { margin: 5px 0; }
    </style>
</head>
<body>
    <h2>Live Graph</h2>

    <div id="channelSelect" class="checkbox-group"></div>
    <canvas id="liveChart" width="800" height="400"></canvas>

    <script>
        let chart;
        let lastModified = 0;
        let selectedChannels = new Set();
        const colorMap = {}; // Mantém cores fixas por canal

        const fixedColors = [
            '#1f77b4', '#ff7f0e', '#2ca02c', '#d62728',
            '#9467bd', '#8c564b', '#e377c2', '#7f7f7f',
            '#bcbd22', '#17becf'
        ];
        let colorIndex = 0;

        function getColorForChannel(channel) {
            if (!colorMap[channel]) {
                colorMap[channel] = fixedColors[colorIndex % fixedColors.length];
                colorIndex++;
            }
            return colorMap[channel];
        }

        async function fetchCSV() {
            try {
                const response = await fetch(`/data.csv?t=${Date.now()}`);
                const text = await response.text();

                const rows = text.trim().split('\n').map(r => r.split(','));
                if (rows.length < 2) return;

                const headers = rows[0];
                const dataRows = rows.slice(1);

                if (document.getElementById('channelSelect').children.length === 0) {
                    populateCheckboxes(headers);
                }

                const timestampIndex = 0;
                const labels = dataRows.map(row => parseFloat(row[timestampIndex]));
                const datasets = [];

                headers.forEach((header, index) => {
                    if (index === timestampIndex || !selectedChannels.has(header)) return;

                    const values = dataRows.map(row => {
                        const val = row[index];
                        return isNaN(val) ? null : parseFloat(val);
                    });

                    datasets.push({
                        label: header,
                        data: labels.map((x, i) => ({ x, y: values[i] })),
                        borderColor: getColorForChannel(header),
                        backgroundColor: getColorForChannel(header),
                        borderWidth: 2,
                        pointRadius: 3,
                        fill: false,
                        tension: 0.1
                    });
                });

                renderChart(datasets);
            } catch (error) {
                console.error("Erro ao buscar CSV:", error);
            }
        }

        function populateCheckboxes(headers) {
            const container = document.getElementById('channelSelect');
            headers.forEach((header, index) => {
                if (index === 0) return;

                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = header;
                checkbox.checked = true;
                selectedChannels.add(header);

                checkbox.addEventListener('change', () => {
                    if (checkbox.checked) {
                        selectedChannels.add(header);
                    } else {
                        selectedChannels.delete(header);
                    }
                    fetchCSV();
                });

                const label = document.createElement('label');
                label.textContent = header;
                label.style.marginRight = "15px";

                container.appendChild(checkbox);
                container.appendChild(label);
            });
        }

        function renderChart(datasets) {
            const ctx = document.getElementById('liveChart').getContext('2d');
            if (chart) chart.destroy();

            const allTimestamps = datasets.flatMap(ds => ds.data.map(p => p.x));
            const maxTimestamp = Math.max(...allTimestamps);
            const minTimestamp = Math.max(0, maxTimestamp - 10);

            chart = new Chart(ctx, {
                type: 'line',
                data: { datasets },
                options: {
                    responsive: true,
                    parsing: false,
                    animation: false,
                    scales: {
                        x: {
                            type: 'linear',
                            title: { display: true, text: 'Timestamp (s)' },
                            min: minTimestamp,
                            max: maxTimestamp,
                            ticks: {
                                callback: function(value) {
                                    return parseFloat(value).toFixed(1);
                                }
                            }
                        },
                        y: {
                            title: { display: true, text: 'Valor' }
                        }
                    },
                    plugins: {
                        legend: {
                            position: 'top'
                        }
                    }
                }
            });
        }

        async function checkForUpdates() {
            try {
                const response = await fetch(`/check-update?t=${Date.now()}`);
                const data = await response.json();
                if (data.last_modified > lastModified) {
                    lastModified = data.last_modified;
                    await fetchCSV();
                }
            } catch (error) {
                console.error("Falha ao verificar atualizações:", error);
            }
        }

        fetchCSV();
        setInterval(checkForUpdates, 1000);
    </script>
</body>
</html>